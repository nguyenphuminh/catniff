export type TensorValue = number | TensorValue[];
export interface TensorOptions {
    shape?: number[];
    strides?: number[];
    grad?: Tensor;
    requiresGrad?: boolean;
    gradFn?: Function;
    children?: Tensor[];
}
export declare class Tensor {
    value: number[] | number;
    readonly shape: number[];
    readonly strides: number[];
    grad?: Tensor;
    requiresGrad: boolean;
    gradFn: Function;
    children: Tensor[];
    constructor(value: TensorValue, options?: TensorOptions);
    static flatten(tensor: TensorValue): number[] | number;
    static getShape(tensor: TensorValue): number[];
    static getStrides(shape: number[]): number[];
    static padShape(stridesA: number[], stridesB: number[], shapeA: number[], shapeB: number[]): number[][];
    static broadcastShapes(shapeA: number[], shapeB: number[]): number[];
    static indexToCoords(index: number, shape: number[], strides: number[]): number[];
    static coordsToIndex(coords: number[], shape: number[], strides: number[]): number;
    static elementWiseAB(tA: Tensor, tB: Tensor, op: (tA: number, tB: number) => number): Tensor;
    static elementWiseSelf(tA: Tensor, op: (tA: number) => number): Tensor;
    elementWiseABDAG(other: TensorValue | Tensor, op: (a: number, b: number) => number, thisGrad?: (self: Tensor, other: Tensor, outGrad: Tensor) => Tensor, otherGrad?: (self: Tensor, other: Tensor, outGrad: Tensor) => Tensor): Tensor;
    elementWiseSelfDAG(op: (a: number) => number, thisGrad?: (self: Tensor, outGrad: Tensor) => Tensor): Tensor;
    static forceTensor(value: TensorValue | Tensor): Tensor;
    static addGrad(tensor: Tensor, accumGrad: Tensor): void;
    squeeze(dims?: number[] | number): Tensor;
    unsqueeze(dim: number): Tensor;
    sum(dims?: number[] | number, keepDims?: boolean): Tensor;
    add(other: TensorValue | Tensor): Tensor;
    sub(other: TensorValue | Tensor): Tensor;
    mul(other: TensorValue | Tensor): Tensor;
    pow(other: TensorValue | Tensor): Tensor;
    div(other: TensorValue | Tensor): Tensor;
    ge(other: TensorValue | Tensor): Tensor;
    le(other: TensorValue | Tensor): Tensor;
    gt(other: TensorValue | Tensor): Tensor;
    lt(other: TensorValue | Tensor): Tensor;
    eq(other: TensorValue | Tensor): Tensor;
    logicalAnd(other: TensorValue | Tensor): Tensor;
    logicalOr(other: TensorValue | Tensor): Tensor;
    logicalXor(other: TensorValue | Tensor): Tensor;
    logicalNot(): Tensor;
    bitwiseAnd(other: TensorValue | Tensor): Tensor;
    bitwiseOr(other: TensorValue | Tensor): Tensor;
    bitwiseXor(other: TensorValue | Tensor): Tensor;
    bitwiseNot(): Tensor;
    bitwiseLeftShift(other: TensorValue | Tensor): Tensor;
    bitwiseRightShift(other: TensorValue | Tensor): Tensor;
    neg(): Tensor;
    abs(): Tensor;
    sign(): Tensor;
    sin(): Tensor;
    cos(): Tensor;
    tan(): Tensor;
    asin(): Tensor;
    acos(): Tensor;
    atan(): Tensor;
    sinh(): Tensor;
    cosh(): Tensor;
    asinh(): Tensor;
    acosh(): Tensor;
    atanh(): Tensor;
    sqrt(): Tensor;
    exp(): Tensor;
    log(): Tensor;
    log2(): Tensor;
    log10(): Tensor;
    log1p(): Tensor;
    relu(): Tensor;
    sigmoid(): Tensor;
    tanh(): Tensor;
    transpose(dim1: number, dim2: number): Tensor;
    t(): Tensor;
    dot(other: TensorValue | Tensor): Tensor;
    mm(other: TensorValue | Tensor): Tensor;
    mv(other: TensorValue | Tensor): Tensor;
    matmul(other: TensorValue | Tensor): Tensor;
    static fullLike(tensor: Tensor, num: number, options?: TensorOptions): Tensor;
    backward(): void;
    val(): any;
    withGrad(requiresGrad: boolean): Tensor;
}
