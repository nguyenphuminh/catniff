export type TensorValue = number | TensorValue[];
export interface TensorOptions {
    shape?: readonly number[];
    strides?: readonly number[];
    grad?: Tensor;
    requiresGrad?: boolean;
    gradFn?: Function;
    children?: Tensor[];
}
export declare class Tensor {
    value: number[] | number;
    readonly shape: readonly number[];
    readonly strides: readonly number[];
    grad?: Tensor;
    requiresGrad: boolean;
    gradFn: Function;
    children: Tensor[];
    constructor(value: TensorValue, options?: TensorOptions);
    static flatten(tensor: TensorValue): number[] | number;
    static getShape(tensor: TensorValue): readonly number[];
    static getStrides(shape: readonly number[]): readonly number[];
    static padShape(stridesA: readonly number[], stridesB: readonly number[], shapeA: readonly number[], shapeB: readonly number[]): [
        readonly number[],
        readonly number[],
        readonly number[],
        readonly number[]
    ];
    static broadcastShapes(shapeA: readonly number[], shapeB: readonly number[]): readonly number[];
    static indexToCoords(index: number, strides: readonly number[]): number[];
    static coordsToUnbroadcastedIndex(coords: number[], shape: readonly number[], strides: readonly number[]): number;
    static coordsToIndex(coords: number[], strides: readonly number[]): number;
    static shapeToSize(shape: readonly number[]): number;
    static elementWiseAB(tA: Tensor, tB: Tensor, op: (tA: number, tB: number) => number): Tensor;
    static elementWiseSelf(tA: Tensor, op: (tA: number) => number): Tensor;
    elementWiseABDAG(other: TensorValue | Tensor, op: (a: number, b: number) => number, thisGrad?: (self: Tensor, other: Tensor, outGrad: Tensor) => Tensor, otherGrad?: (self: Tensor, other: Tensor, outGrad: Tensor) => Tensor): Tensor;
    elementWiseSelfDAG(op: (a: number) => number, thisGrad?: (self: Tensor, outGrad: Tensor) => Tensor): Tensor;
    static forceTensor(value: TensorValue | Tensor): Tensor;
    static addGrad(tensor: Tensor, accumGrad: Tensor): void;
    squeeze(dims?: number[] | number): Tensor;
    unsqueeze(dim: number): Tensor;
    sum(dims?: number[] | number, keepDims?: boolean): Tensor;
    prod(dims?: number[] | number, keepDims?: boolean): Tensor;
    mean(dims?: number[] | number, keepDims?: boolean): Tensor;
    max(dims?: number[] | number, keepDims?: boolean): Tensor;
    min(dims?: number[] | number, keepDims?: boolean): Tensor;
    add(other: TensorValue | Tensor): Tensor;
    sub(other: TensorValue | Tensor): Tensor;
    subtract: (other: TensorValue | Tensor) => Tensor;
    mul(other: TensorValue | Tensor): Tensor;
    multiply: (other: TensorValue | Tensor) => Tensor;
    pow(other: TensorValue | Tensor): Tensor;
    div(other: TensorValue | Tensor): Tensor;
    divide: (other: TensorValue | Tensor) => Tensor;
    remainder(other: TensorValue | Tensor): Tensor;
    ge(other: TensorValue | Tensor): Tensor;
    greaterEqual: (other: TensorValue | Tensor) => Tensor;
    le(other: TensorValue | Tensor): Tensor;
    lessEqual: (other: TensorValue | Tensor) => Tensor;
    gt(other: TensorValue | Tensor): Tensor;
    greater: (other: TensorValue | Tensor) => Tensor;
    lt(other: TensorValue | Tensor): Tensor;
    less: (other: TensorValue | Tensor) => Tensor;
    eq(other: TensorValue | Tensor): Tensor;
    equal: (other: TensorValue | Tensor) => Tensor;
    ne(other: TensorValue | Tensor): Tensor;
    notEqual: (other: TensorValue | Tensor) => Tensor;
    logicalAnd(other: TensorValue | Tensor): Tensor;
    logicalOr(other: TensorValue | Tensor): Tensor;
    logicalXor(other: TensorValue | Tensor): Tensor;
    logicalNot(): Tensor;
    bitwiseAnd(other: TensorValue | Tensor): Tensor;
    bitwiseOr(other: TensorValue | Tensor): Tensor;
    bitwiseXor(other: TensorValue | Tensor): Tensor;
    bitwiseNot(): Tensor;
    bitwiseLeftShift(other: TensorValue | Tensor): Tensor;
    bitwiseRightShift(other: TensorValue | Tensor): Tensor;
    neg(): Tensor;
    negative: () => Tensor;
    reciprocal(): Tensor;
    square(): Tensor;
    abs(): Tensor;
    absolute: () => Tensor;
    sign(): Tensor;
    sin(): Tensor;
    cos(): Tensor;
    tan(): Tensor;
    asin(): Tensor;
    arcsin: () => Tensor;
    acos(): Tensor;
    arccos: () => Tensor;
    atan(): Tensor;
    arctan: () => Tensor;
    atan2(other: TensorValue | Tensor): Tensor;
    arctan2: (other: TensorValue | Tensor) => Tensor;
    sinh(): Tensor;
    cosh(): Tensor;
    asinh(): Tensor;
    arcsinh: () => Tensor;
    acosh(): Tensor;
    arccosh: () => Tensor;
    atanh(): Tensor;
    arctanh: () => Tensor;
    deg2rad(): Tensor;
    rad2deg(): Tensor;
    sqrt(): Tensor;
    rsqrt(): Tensor;
    exp(): Tensor;
    exp2(): Tensor;
    expm1(): Tensor;
    log(): Tensor;
    log2(): Tensor;
    log10(): Tensor;
    log1p(): Tensor;
    relu(): Tensor;
    sigmoid(): Tensor;
    tanh(): Tensor;
    softplus(): Tensor;
    softsign(): Tensor;
    silu(): Tensor;
    mish(): Tensor;
    maximum(other: TensorValue | Tensor): Tensor;
    minimum(other: TensorValue | Tensor): Tensor;
    round(): Tensor;
    floor(): Tensor;
    ceil(): Tensor;
    trunc(): Tensor;
    fix: () => Tensor;
    frac(): Tensor;
    clip(min: number, max: number): Tensor;
    clamp: (min: number, max: number) => Tensor;
    erf(): Tensor;
    erfc(): Tensor;
    erfinv(): Tensor;
    transpose(dim1: number, dim2: number): Tensor;
    swapaxes: (dim1: number, dim2: number) => Tensor;
    swapdims: (dim1: number, dim2: number) => Tensor;
    t(): Tensor;
    dot(other: TensorValue | Tensor): Tensor;
    mm(other: TensorValue | Tensor): Tensor;
    mv(other: TensorValue | Tensor): Tensor;
    matmul(other: TensorValue | Tensor): Tensor;
    static full(shape: number[], num: number, options?: TensorOptions): Tensor;
    static fullLike(tensor: Tensor, num: number, options?: TensorOptions): Tensor;
    static ones(shape?: number[], options?: TensorOptions): Tensor;
    static onesLike(tensor: Tensor, options?: TensorOptions): Tensor;
    static zeros(shape?: number[], options?: TensorOptions): Tensor;
    static zerosLike(tensor: Tensor, options?: TensorOptions): Tensor;
    static rand(shape?: number[], options?: TensorOptions): Tensor;
    static randLike(tensor: Tensor, options?: TensorOptions): Tensor;
    static randn(shape?: number[], options?: TensorOptions): Tensor;
    static randnLike(tensor: Tensor, options?: TensorOptions): Tensor;
    static randint(shape: number[], low: number, high: number, options?: TensorOptions): Tensor;
    static randintLike(tensor: Tensor, low: number, high: number, options?: TensorOptions): Tensor;
    static normal(shape: number[], mean: number, stdDev: number, options?: TensorOptions): Tensor;
    static uniform(shape: number[], low: number, high: number, options?: TensorOptions): Tensor;
    backward(): void;
    val(): TensorValue;
    withGrad(requiresGrad: boolean): Tensor;
}
