import { Backend } from "./backend";
import { dtype, MemoryBuffer } from "./dtype";
export type TensorValue = number | ArrayLike<TensorValue>;
export interface TensorOptions {
    shape?: number[];
    strides?: number[];
    offset?: number;
    numel?: number;
    grad?: Tensor;
    requiresGrad?: boolean;
    gradFn?: Function;
    children?: Tensor[];
    device?: string;
    dtype?: dtype;
}
export declare class Tensor {
    value: MemoryBuffer;
    shape: number[];
    strides: number[];
    offset: number;
    numel: number;
    grad?: Tensor;
    requiresGrad: boolean;
    gradFn: Function;
    children: Tensor[];
    device: string;
    dtype: dtype;
    static training: boolean;
    static noGrad: boolean;
    static createGraph: boolean;
    constructor(value: TensorValue, options?: TensorOptions);
    static flattenValue(tensorValue: TensorValue): ArrayLike<number>;
    static getShape(tensorValue: TensorValue): number[];
    static getStrides(shape: number[]): number[];
    static padShape(stridesA: number[], stridesB: number[], shapeA: number[], shapeB: number[]): [
        number[],
        number[],
        number[],
        number[]
    ];
    static broadcastShapes(shapeA: number[], shapeB: number[]): number[];
    static indexToCoords(index: number, strides: number[]): number[];
    static coordsToUnbroadcastedIndex(coords: number[], shape: number[], strides: number[]): number;
    static coordsToIndex(coords: number[], strides: number[]): number;
    static shapeToSize(shape: number[]): number;
    static getResultDtype(type1: dtype, type2: dtype): dtype;
    handleOther(other: Tensor | TensorValue): Tensor;
    static elementWiseAB(tA: Tensor, tB: Tensor, op: (tA: number, tB: number) => number): Tensor;
    static elementWiseSelf(tA: Tensor, op: (tA: number) => number): Tensor;
    elementWiseABDAG(other: TensorValue | Tensor, op: (a: number, b: number) => number, thisGrad?: (self: Tensor, other: Tensor, outGrad: Tensor) => Tensor, otherGrad?: (self: Tensor, other: Tensor, outGrad: Tensor) => Tensor): Tensor;
    elementWiseSelfDAG(op: (a: number) => number, thisGrad?: (self: Tensor, outGrad: Tensor) => Tensor): Tensor;
    static addGrad(tensor: Tensor, accumGrad: Tensor): void;
    static normalizeDims(dims: number[], numDims: number): number[];
    isContiguous(): boolean;
    contiguous(): Tensor;
    view(newShape: number[]): Tensor;
    reshape(newShape: number[]): Tensor;
    flatten(startDim?: number, endDim?: number): Tensor;
    transpose(dim1: number, dim2: number): Tensor;
    swapaxes: (dim1: number, dim2: number) => Tensor;
    swapdims: (dim1: number, dim2: number) => Tensor;
    t(): Tensor;
    permute(dims: number[]): Tensor;
    indexWithArray(indices: number[]): Tensor;
    index(indices: Tensor | TensorValue): Tensor;
    slice(ranges: number[][]): Tensor;
    chunk(chunks: number, dim?: number): Tensor[];
    expand(newShape: number[]): Tensor;
    cat(other: Tensor | TensorValue, dim?: number): Tensor;
    squeeze(dims?: number[] | number): Tensor;
    unsqueeze(dim: number): Tensor;
    static reduce(tensor: Tensor, dims: number[] | number | undefined, keepDims: boolean, config: {
        identity: number;
        operation: (accumulator: number, value: number) => number;
        needsCounters?: boolean;
        postProcess?: (options: {
            values: MemoryBuffer;
            counters?: MemoryBuffer;
        }) => void;
        needsShareCounts?: boolean;
        gradientFn: (options: {
            outputValue: MemoryBuffer;
            originalValue: MemoryBuffer;
            counters: MemoryBuffer;
            shareCounts: MemoryBuffer;
            realIndex: number;
            outIndex: number;
        }) => number;
    }): Tensor;
    sum(dims?: number[] | number, keepDims?: boolean): Tensor;
    prod(dims?: number[] | number, keepDims?: boolean): Tensor;
    mean(dims?: number[] | number, keepDims?: boolean): Tensor;
    max(dims?: number[] | number, keepDims?: boolean): Tensor;
    min(dims?: number[] | number, keepDims?: boolean): Tensor;
    all(dims?: number[] | number, keepDims?: boolean): Tensor;
    any(dims?: number[] | number, keepDims?: boolean): Tensor;
    var(dims?: number[] | number, keepDims?: boolean): Tensor;
    std(dims?: number[] | number, keepDims?: boolean): Tensor;
    softmax(dim?: number): Tensor;
    softmin(dim?: number): Tensor;
    add(other: TensorValue | Tensor): Tensor;
    sub(other: TensorValue | Tensor): Tensor;
    subtract: (other: TensorValue | Tensor) => Tensor;
    mul(other: TensorValue | Tensor): Tensor;
    multiply: (other: TensorValue | Tensor) => Tensor;
    pow(other: TensorValue | Tensor): Tensor;
    div(other: TensorValue | Tensor): Tensor;
    divide: (other: TensorValue | Tensor) => Tensor;
    remainder(other: TensorValue | Tensor): Tensor;
    ge(other: TensorValue | Tensor): Tensor;
    greaterEqual: (other: TensorValue | Tensor) => Tensor;
    le(other: TensorValue | Tensor): Tensor;
    lessEqual: (other: TensorValue | Tensor) => Tensor;
    gt(other: TensorValue | Tensor): Tensor;
    greater: (other: TensorValue | Tensor) => Tensor;
    lt(other: TensorValue | Tensor): Tensor;
    less: (other: TensorValue | Tensor) => Tensor;
    eq(other: TensorValue | Tensor): Tensor;
    equal: (other: TensorValue | Tensor) => Tensor;
    ne(other: TensorValue | Tensor): Tensor;
    notEqual: (other: TensorValue | Tensor) => Tensor;
    logicalAnd(other: TensorValue | Tensor): Tensor;
    logicalOr(other: TensorValue | Tensor): Tensor;
    logicalXor(other: TensorValue | Tensor): Tensor;
    logicalNot(): Tensor;
    bitwiseAnd(other: TensorValue | Tensor): Tensor;
    bitwiseOr(other: TensorValue | Tensor): Tensor;
    bitwiseXor(other: TensorValue | Tensor): Tensor;
    bitwiseNot(): Tensor;
    bitwiseLeftShift(other: TensorValue | Tensor): Tensor;
    bitwiseRightShift(other: TensorValue | Tensor): Tensor;
    neg(): Tensor;
    negative: () => Tensor;
    reciprocal(): Tensor;
    square(): Tensor;
    abs(): Tensor;
    absolute: () => Tensor;
    sign(): Tensor;
    sin(): Tensor;
    cos(): Tensor;
    tan(): Tensor;
    asin(): Tensor;
    arcsin: () => Tensor;
    acos(): Tensor;
    arccos: () => Tensor;
    atan(): Tensor;
    arctan: () => Tensor;
    atan2(other: TensorValue | Tensor): Tensor;
    arctan2: (other: TensorValue | Tensor) => Tensor;
    sinh(): Tensor;
    cosh(): Tensor;
    asinh(): Tensor;
    arcsinh: () => Tensor;
    acosh(): Tensor;
    arccosh: () => Tensor;
    atanh(): Tensor;
    arctanh: () => Tensor;
    deg2rad(): Tensor;
    rad2deg(): Tensor;
    sqrt(): Tensor;
    rsqrt(): Tensor;
    exp(): Tensor;
    exp2(): Tensor;
    expm1(): Tensor;
    log(): Tensor;
    log2(): Tensor;
    log10(): Tensor;
    log1p(): Tensor;
    relu(): Tensor;
    leakyRelu(negativeSlope?: number): Tensor;
    elu(alpha?: number): Tensor;
    selu(): Tensor;
    celu(alpha?: number): Tensor;
    sigmoid(): Tensor;
    tanh(): Tensor;
    softplus(): Tensor;
    softsign(): Tensor;
    silu(): Tensor;
    mish(): Tensor;
    gelu(approximate?: string): Tensor;
    maximum(other: TensorValue | Tensor): Tensor;
    minimum(other: TensorValue | Tensor): Tensor;
    round(): Tensor;
    floor(): Tensor;
    ceil(): Tensor;
    trunc(): Tensor;
    fix: () => Tensor;
    frac(): Tensor;
    clip(min: number, max: number): Tensor;
    clamp: (min: number, max: number) => Tensor;
    erf(): Tensor;
    erfc(): Tensor;
    erfinv(): Tensor;
    dot(other: TensorValue | Tensor): Tensor;
    mm(other: TensorValue | Tensor): Tensor;
    bmm(other: TensorValue | Tensor): Tensor;
    mv(other: TensorValue | Tensor): Tensor;
    matmul(other: TensorValue | Tensor): Tensor;
    dropout(rate: number): Tensor;
    triu(diagonal?: number): Tensor;
    tril(diagonal?: number): Tensor;
    maskedFill(mask: Tensor | TensorValue, value: number): Tensor;
    static full(shape: number[], num: number, options?: TensorOptions): Tensor;
    static fullLike(tensor: Tensor, num: number, options?: TensorOptions): Tensor;
    static ones(shape?: number[], options?: TensorOptions): Tensor;
    static onesLike(tensor: Tensor, options?: TensorOptions): Tensor;
    static zeros(shape?: number[], options?: TensorOptions): Tensor;
    static zerosLike(tensor: Tensor, options?: TensorOptions): Tensor;
    static rand(shape?: number[], options?: TensorOptions): Tensor;
    static randLike(tensor: Tensor, options?: TensorOptions): Tensor;
    static randn(shape?: number[], options?: TensorOptions): Tensor;
    static randnLike(tensor: Tensor, options?: TensorOptions): Tensor;
    static randint(shape: number[], low: number, high: number, options?: TensorOptions): Tensor;
    static randintLike(tensor: Tensor, low: number, high: number, options?: TensorOptions): Tensor;
    static randperm(n: number, options?: TensorOptions): Tensor;
    static normal(shape: number[], mean: number, stdDev: number, options?: TensorOptions): Tensor;
    static uniform(shape: number[], low: number, high: number, options?: TensorOptions): Tensor;
    static arange(start: number, stop?: number, step?: number, options?: TensorOptions): Tensor;
    static linspace(start: number, stop: number, steps: number, options?: TensorOptions): Tensor;
    static eye(n: number, m?: number, options?: TensorOptions): Tensor;
    backward(options?: {
        zeroGrad?: boolean;
    }): void;
    val(): TensorValue;
    detach(): Tensor;
    clone(): Tensor;
    replace(other: Tensor | TensorValue): Tensor;
    cast(dtype: dtype): Tensor;
    static backends: Map<string, Backend>;
    to(device: string): Tensor;
    to_(device: string): Tensor;
}
