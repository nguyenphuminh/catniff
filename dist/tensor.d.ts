export type Tensor = number | Tensor[];
export declare class TensorMath {
    static create(num: number, shape: number[]): Tensor;
    static getShape(tA: Tensor): number[];
    static padShape(tA: Tensor, tB: Tensor): [Tensor[], Tensor[]];
    static elementWiseAB(tA: Tensor, tB: Tensor, op: (tA: number, tB: number) => number): Tensor;
    static elementWiseSelf(tA: Tensor, op: (tA: number) => number): Tensor;
    static add(tA: Tensor, tB: Tensor): Tensor;
    static sub(tA: Tensor, tB: Tensor): Tensor;
    static mul(tA: Tensor, tB: Tensor): Tensor;
    static pow(tA: Tensor, tB: Tensor): Tensor;
    static div(tA: Tensor, tB: Tensor): Tensor;
    static gt(tA: Tensor, tB: Tensor): Tensor;
    static lt(tA: Tensor, tB: Tensor): Tensor;
    static ge(tA: Tensor, tB: Tensor): Tensor;
    static le(tA: Tensor, tB: Tensor): Tensor;
    static eq(tA: Tensor, tB: Tensor): Tensor;
    static logicalAnd(tA: Tensor, tB: Tensor): Tensor;
    static logicalOr(tA: Tensor, tB: Tensor): Tensor;
    static logicalXor(tA: Tensor, tB: Tensor): Tensor;
    static logicalNot(tA: Tensor): Tensor;
    static bitwiseAnd(tA: Tensor, tB: Tensor): Tensor;
    static bitwiseOr(tA: Tensor, tB: Tensor): Tensor;
    static bitwiseXor(tA: Tensor, tB: Tensor): Tensor;
    static bitwiseNot(tA: Tensor): Tensor;
    static bitwiseLeftShift(tA: Tensor, tB: Tensor): Tensor;
    static bitwiseRightShift(tA: Tensor, tB: Tensor): Tensor;
    static neg(tA: Tensor): Tensor;
    static abs(tA: Tensor): Tensor;
    static sign(tA: Tensor): Tensor;
    static sin(tA: Tensor): Tensor;
    static cos(tA: Tensor): Tensor;
    static tan(tA: Tensor): Tensor;
    static asin(tA: Tensor): Tensor;
    static acos(tA: Tensor): Tensor;
    static atan(tA: Tensor): Tensor;
    static sinh(tA: Tensor): Tensor;
    static cosh(tA: Tensor): Tensor;
    static asinh(tA: Tensor): Tensor;
    static acosh(tA: Tensor): Tensor;
    static atanh(tA: Tensor): Tensor;
    static sqrt(tA: Tensor): Tensor;
    static exp(tA: Tensor): Tensor;
    static log(tA: Tensor): Tensor;
    static log2(tA: Tensor): Tensor;
    static log10(tA: Tensor): Tensor;
    static log1p(tA: Tensor): Tensor;
    static relu(tA: Tensor): Tensor;
    static sigmoid(tA: Tensor): Tensor;
    static tanh(tA: Tensor): Tensor;
    static squeezeAxis(tA: Tensor, axis: number): Tensor;
    static squeeze(tA: Tensor, dims?: number[] | number): Tensor;
    static sumAxis(tA: Tensor, axis: number): Tensor;
    static sum(tA: Tensor, dims?: number[] | number, keepDims?: boolean): Tensor;
    static t(tA: Tensor): Tensor;
    static dot(tA: Tensor, tB: Tensor): Tensor;
    static mm(tA: Tensor, tB: Tensor): Tensor;
    static mv(tA: Tensor, tB: Tensor): Tensor;
    static matmul(tA: Tensor, tB: Tensor): Tensor;
}
