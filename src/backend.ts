import { Tensor, TensorValue } from "./core";

export interface Backend {
    sum?(tensor: Tensor, dims?: number[] | number, keepDims?: boolean): Tensor;
    prod?(tensor: Tensor, dims?: number[] | number, keepDims?: boolean): Tensor;
    mean?(tensor: Tensor, dims?: number[] | number, keepDims?: boolean): Tensor;
    max?(tensor: Tensor, dims?: number[] | number, keepDims?: boolean): Tensor;
    min?(tensor: Tensor, dims?: number[] | number, keepDims?: boolean): Tensor;
    softmax?(tensor: Tensor, dims?: number[] | number): Tensor;
    add?(self: Tensor, other: Tensor | TensorValue): Tensor;
    sub?(self: Tensor, other: Tensor | TensorValue): Tensor;
    mul?(self: Tensor, other: Tensor | TensorValue): Tensor;
    pow?(self: Tensor, other: Tensor | TensorValue): Tensor;
    div?(self: Tensor, other: Tensor | TensorValue): Tensor;
    remainder?(self: Tensor, other: Tensor | TensorValue): Tensor;
    ge?(self: Tensor, other: Tensor | TensorValue): Tensor;
    le?(self: Tensor, other: Tensor | TensorValue): Tensor;
    gt?(self: Tensor, other: Tensor | TensorValue): Tensor;
    lt?(self: Tensor, other: Tensor | TensorValue): Tensor;
    eq?(self: Tensor, other: Tensor | TensorValue): Tensor;
    ne?(self: Tensor, other: Tensor | TensorValue): Tensor;
    logicalAnd?(self: Tensor, other: Tensor | TensorValue): Tensor;
    logicalOr?(self: Tensor, other: Tensor | TensorValue): Tensor;
    logicalXor?(self: Tensor, other: Tensor | TensorValue): Tensor;
    logicalNot?(self: Tensor): Tensor;
    bitwiseAnd?(self: Tensor, other: Tensor | TensorValue): Tensor;
    bitwiseOr?(self: Tensor, other: Tensor | TensorValue): Tensor;
    bitwiseXor?(self: Tensor, other: Tensor | TensorValue): Tensor;
    bitwiseNot?(self: Tensor): Tensor;
    bitwiseLeftShift?(self: Tensor, other: Tensor | TensorValue): Tensor;
    bitwiseRightShift?(self: Tensor, other: Tensor | TensorValue): Tensor;
    neg?(self: Tensor): Tensor;
    reciprocal?(self: Tensor): Tensor;
    square?(self: Tensor): Tensor;
    abs?(self: Tensor): Tensor;
    sign?(self: Tensor): Tensor;
    sin?(self: Tensor): Tensor;
    cos?(self: Tensor): Tensor;
    tan?(self: Tensor): Tensor;
    asin?(self: Tensor): Tensor;
    acos?(self: Tensor): Tensor;
    atan?(self: Tensor): Tensor;
    atan2?(self: Tensor): Tensor;
    sinh?(self: Tensor): Tensor;
    cosh?(self: Tensor): Tensor;
    asinh?(self: Tensor): Tensor;
    acosh?(self: Tensor): Tensor;
    atanh?(self: Tensor): Tensor;
    deg2rad?(self: Tensor): Tensor;
    rad2deg?(self: Tensor): Tensor;
    sqrt?(self: Tensor): Tensor;
    rsqrt?(self: Tensor): Tensor;
    exp?(self: Tensor): Tensor;
    exp2?(self: Tensor): Tensor;
    expm1?(self: Tensor): Tensor;
    log?(self: Tensor): Tensor;
    log2?(self: Tensor): Tensor;
    log10?(self: Tensor): Tensor;
    log1p?(self: Tensor): Tensor;
    relu?(self: Tensor): Tensor;
    sigmoid?(self: Tensor): Tensor;
    tanh?(self: Tensor): Tensor;
    softplus?(self: Tensor): Tensor;
    softsign?(self: Tensor): Tensor;
    silu?(self: Tensor): Tensor;
    mish?(self: Tensor): Tensor;
    maximum?(self: Tensor, other: Tensor | TensorValue): Tensor;
    minimum?(self: Tensor, other: Tensor | TensorValue): Tensor;
    round?(self: Tensor): Tensor;
    floor?(self: Tensor): Tensor;
    ceil?(self: Tensor): Tensor;
    trunc?(self: Tensor): Tensor;
    frac?(self: Tensor): Tensor;
    clip?(self: Tensor, min: number, max: number): Tensor;
    erf?(self: Tensor): Tensor;
    erfc?(self: Tensor): Tensor;
    erfinv?(self: Tensor): Tensor;
    dot?(self: Tensor, other: Tensor | TensorValue): Tensor;
    mm?(self: Tensor, other: Tensor | TensorValue): Tensor;
    bmm?(self: Tensor, other: Tensor | TensorValue): Tensor;
    mv?(self: Tensor, other: Tensor | TensorValue): Tensor;
    matmul?(self: Tensor, other: Tensor | TensorValue): Tensor;
    to?(tensor: Tensor): Tensor;
}
